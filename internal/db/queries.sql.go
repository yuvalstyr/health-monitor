// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createGauge = `-- name: CreateGauge :one
INSERT INTO gauges (name, description, target, unit, icon)
VALUES (?, ?, CAST(? AS REAL), ?, ?)
RETURNING id, name, description, target, unit, icon, created_at, updated_at
`

type CreateGaugeParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Column3     float64        `json:"column_3"`
	Unit        string         `json:"unit"`
	Icon        string         `json:"icon"`
}

func (q *Queries) CreateGauge(ctx context.Context, arg CreateGaugeParams) (Gauge, error) {
	row := q.db.QueryRowContext(ctx, createGauge,
		arg.Name,
		arg.Description,
		arg.Column3,
		arg.Unit,
		arg.Icon,
	)
	var i Gauge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Target,
		&i.Unit,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGaugeValue = `-- name: CreateGaugeValue :exec
INSERT INTO gauge_values (gauge_id, value, date)
VALUES (?, CAST(? AS REAL), ?)
`

type CreateGaugeValueParams struct {
	GaugeID int64     `json:"gauge_id"`
	Column2 float64   `json:"column_2"`
	Date    time.Time `json:"date"`
}

func (q *Queries) CreateGaugeValue(ctx context.Context, arg CreateGaugeValueParams) error {
	_, err := q.db.ExecContext(ctx, createGaugeValue, arg.GaugeID, arg.Column2, arg.Date)
	return err
}

const deleteGauge = `-- name: DeleteGauge :exec
DELETE FROM gauges WHERE id = ?
`

func (q *Queries) DeleteGauge(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteGauge, id)
	return err
}

const getCurrentValue = `-- name: GetCurrentValue :one
SELECT CAST(COALESCE(
    (SELECT value FROM gauge_values WHERE gauge_id = ? ORDER BY date DESC LIMIT 1),
    0.0
) AS REAL) as value
`

func (q *Queries) GetCurrentValue(ctx context.Context, gaugeID int64) (float64, error) {
	row := q.db.QueryRowContext(ctx, getCurrentValue, gaugeID)
	var value float64
	err := row.Scan(&value)
	return value, err
}

const getGauge = `-- name: GetGauge :one
SELECT id, name, description, target, unit, icon, created_at, updated_at FROM gauges WHERE id = ? LIMIT 1
`

func (q *Queries) GetGauge(ctx context.Context, id int64) (Gauge, error) {
	row := q.db.QueryRowContext(ctx, getGauge, id)
	var i Gauge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Target,
		&i.Unit,
		&i.Icon,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGaugeHistory = `-- name: GetGaugeHistory :many
SELECT strftime('%Y-%m', date) as month,
       CAST(AVG(value) AS REAL) as average_value
FROM gauge_values
WHERE gauge_id = ?
GROUP BY strftime('%Y-%m', date)
ORDER BY month DESC
`

type GetGaugeHistoryRow struct {
	Month        interface{} `json:"month"`
	AverageValue float64     `json:"average_value"`
}

func (q *Queries) GetGaugeHistory(ctx context.Context, gaugeID int64) ([]GetGaugeHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getGaugeHistory, gaugeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGaugeHistoryRow{}
	for rows.Next() {
		var i GetGaugeHistoryRow
		if err := rows.Scan(&i.Month, &i.AverageValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGauges = `-- name: ListGauges :many
SELECT id, name, description, target, unit, icon, created_at, updated_at FROM gauges ORDER BY name
`

func (q *Queries) ListGauges(ctx context.Context) ([]Gauge, error) {
	rows, err := q.db.QueryContext(ctx, listGauges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Gauge{}
	for rows.Next() {
		var i Gauge
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Target,
			&i.Unit,
			&i.Icon,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGauge = `-- name: UpdateGauge :exec
UPDATE gauges
SET name = ?,
    description = ?,
    target = CAST(? AS REAL),
    unit = ?,
    icon = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateGaugeParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Column3     float64        `json:"column_3"`
	Unit        string         `json:"unit"`
	Icon        string         `json:"icon"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateGauge(ctx context.Context, arg UpdateGaugeParams) error {
	_, err := q.db.ExecContext(ctx, updateGauge,
		arg.Name,
		arg.Description,
		arg.Column3,
		arg.Unit,
		arg.Icon,
		arg.ID,
	)
	return err
}
