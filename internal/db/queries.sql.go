// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createGauge = `-- name: CreateGauge :one
INSERT INTO gauges (name, description, target, value, unit, icon, frequency, direction)
VALUES (?, ?, ?, 0, ?, ?, ?, ?)
RETURNING id, name, description, target, value, unit, icon, frequency, direction, created_at, updated_at
`

type CreateGaugeParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Target      float64        `json:"target"`
	Unit        string         `json:"unit"`
	Icon        string         `json:"icon"`
	Frequency   string         `json:"frequency"`
	Direction   string         `json:"direction"`
}

func (q *Queries) CreateGauge(ctx context.Context, arg CreateGaugeParams) (Gauge, error) {
	row := q.db.QueryRowContext(ctx, createGauge,
		arg.Name,
		arg.Description,
		arg.Target,
		arg.Unit,
		arg.Icon,
		arg.Frequency,
		arg.Direction,
	)
	var i Gauge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Target,
		&i.Value,
		&i.Unit,
		&i.Icon,
		&i.Frequency,
		&i.Direction,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGaugeValue = `-- name: CreateGaugeValue :exec
INSERT INTO gauge_values (gauge_id, value, date)
VALUES (?, CAST(? AS REAL), ?)
`

type CreateGaugeValueParams struct {
	GaugeID int64     `json:"gauge_id"`
	Column2 float64   `json:"column_2"`
	Date    time.Time `json:"date"`
}

func (q *Queries) CreateGaugeValue(ctx context.Context, arg CreateGaugeValueParams) error {
	_, err := q.db.ExecContext(ctx, createGaugeValue, arg.GaugeID, arg.Column2, arg.Date)
	return err
}

const deleteGauge = `-- name: DeleteGauge :exec
DELETE FROM gauges WHERE id = ?
`

func (q *Queries) DeleteGauge(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteGauge, id)
	return err
}

const getCurrentValue = `-- name: GetCurrentValue :one
SELECT CAST(COALESCE(
    (SELECT value FROM gauge_values WHERE gauge_id = ? ORDER BY date DESC LIMIT 1),
    0.0
) AS REAL) as value
`

func (q *Queries) GetCurrentValue(ctx context.Context, gaugeID int64) (float64, error) {
	row := q.db.QueryRowContext(ctx, getCurrentValue, gaugeID)
	var value float64
	err := row.Scan(&value)
	return value, err
}

const getGauge = `-- name: GetGauge :one
SELECT id, name, description, target, value, unit, icon, frequency, direction, created_at, updated_at FROM gauges WHERE id = ? LIMIT 1
`

func (q *Queries) GetGauge(ctx context.Context, id int64) (Gauge, error) {
	row := q.db.QueryRowContext(ctx, getGauge, id)
	var i Gauge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Target,
		&i.Value,
		&i.Unit,
		&i.Icon,
		&i.Frequency,
		&i.Direction,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGaugeHistory = `-- name: GetGaugeHistory :many
SELECT strftime('%Y-%m', date) as month,
       CAST(AVG(value) AS REAL) as average_value
FROM gauge_values
WHERE gauge_id = ?
GROUP BY strftime('%Y-%m', date)
ORDER BY month DESC
`

type GetGaugeHistoryRow struct {
	Month        interface{} `json:"month"`
	AverageValue float64     `json:"average_value"`
}

func (q *Queries) GetGaugeHistory(ctx context.Context, gaugeID int64) ([]GetGaugeHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getGaugeHistory, gaugeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGaugeHistoryRow{}
	for rows.Next() {
		var i GetGaugeHistoryRow
		if err := rows.Scan(&i.Month, &i.AverageValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGaugeValues = `-- name: GetGaugeValues :many
SELECT id, gauge_id, value, date FROM gauge_values 
WHERE gauge_id = ?
ORDER BY date DESC
`

func (q *Queries) GetGaugeValues(ctx context.Context, gaugeID int64) ([]GaugeValue, error) {
	rows, err := q.db.QueryContext(ctx, getGaugeValues, gaugeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GaugeValue{}
	for rows.Next() {
		var i GaugeValue
		if err := rows.Scan(
			&i.ID,
			&i.GaugeID,
			&i.Value,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGauges = `-- name: ListGauges :many
SELECT id, name, description, target, value, unit, icon, frequency, direction, created_at, updated_at FROM gauges ORDER BY name
`

func (q *Queries) ListGauges(ctx context.Context) ([]Gauge, error) {
	rows, err := q.db.QueryContext(ctx, listGauges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Gauge{}
	for rows.Next() {
		var i Gauge
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Target,
			&i.Value,
			&i.Unit,
			&i.Icon,
			&i.Frequency,
			&i.Direction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGauge = `-- name: UpdateGauge :exec
UPDATE gauges
SET name = ?,
    description = ?,
    target = ?,
    unit = ?,
    icon = ?,
    frequency = ?,
    direction = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateGaugeParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Target      float64        `json:"target"`
	Unit        string         `json:"unit"`
	Icon        string         `json:"icon"`
	Frequency   string         `json:"frequency"`
	Direction   string         `json:"direction"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateGauge(ctx context.Context, arg UpdateGaugeParams) error {
	_, err := q.db.ExecContext(ctx, updateGauge,
		arg.Name,
		arg.Description,
		arg.Target,
		arg.Unit,
		arg.Icon,
		arg.Frequency,
		arg.Direction,
		arg.ID,
	)
	return err
}

const updateGaugeValue = `-- name: UpdateGaugeValue :exec
UPDATE gauges
SET value = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateGaugeValueParams struct {
	Value float64 `json:"value"`
	ID    int64   `json:"id"`
}

func (q *Queries) UpdateGaugeValue(ctx context.Context, arg UpdateGaugeValueParams) error {
	_, err := q.db.ExecContext(ctx, updateGaugeValue, arg.Value, arg.ID)
	return err
}
